# JVM常量池和运行时常量池

[JVM常量池和运行时常量池_jvm 常量池和运行时常量池_wen-pan的博客-CSDN博客](https://blog.csdn.net/Hellowenpan/article/details/120726909)

# JVM线程属于用户态还是内核态

[一文理解JVM线程属于用户态还是内核态-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1839593)

# DirectByteBuffer直接内存(堆外内存)是怎么被回收的？

[DirectByteBuffer直接内存(堆外内存)是怎么被回收的？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/465352120)

# Java Reference核心原理分析

JVM在GC时如果当前对象只被Reference对象引用，JVM会根据Reference具体类型与堆内存的使用情况决定是否把对应的Reference对象加入到一个由Reference构成的pending链表上，如果能加入pending链表JVM同时会通知ReferenceHandler线程进行处理。ReferenceHandler线程是在Reference类被初始化时调用的，其是一个守护进程并且拥有最高的优先级。

https://cloud.tencent.com/developer/news/710974

# 七种作用于不同年代的垃圾收集器

![image-20230925205437598](C:\Users\李凯\AppData\Roaming\Typora\typora-user-images\image-20230925205437598.png)

# JMM

# 浅谈JMM和并发三大特性(volatile、MESI、内存屏障)

https://juejin.cn/post/7115665196957302820?searchId=20231023120639C7DFC4E8247AB923F2F1



> ​		CPU 从单核发展为多核，增加缓存，导致出现了多个核间的缓存一致性问题 --> 为了解决缓存数据一致性问题，提出了 MESI 协议 --> 完全遵守 MESI 又会给 CPU 带来性能问题 --> CPU 设计者又增加 **store buffer** 和 **invalid queue** --> 又导致了缓存的顺序一致性变为了弱缓存一致性 --> 需要缓存的顺序一致性的，就需要软件工程师自己在合适的地方添加内存屏障



有了MESI为什么还要有volatile呢

Java代码会有JIT编译器进行指令重排来进行优化，实现是弱顺序一致性。在单线程下还好，最终的结果不会发生变化，但在多线程环境下，这个指令重排就很恶心，倘若发生了指令重排，我们根本不知道程序会按照什么顺序去执行，出现各种错误，所以在多线程环境下，我们要禁止指令重排，volatile其实保证了程序的强顺序一致性，在需要禁止指令重排的地方用volatile来通过插入内存屏障来保证，实现有序性。

MESI它始终抱枕的是缓存之间的数据一致性。



# JVM总体概括

## jvm类加载过程

三个阶段：装载 -> 链接 -> 初始化

1、装载：将本地系统中（硬盘中）中的class文件信息加载到内存中（方法区），jvm会使用读取到的字节码数据来创建一个java.lang.Class对象，这个对象中包含了类的元数据信息，如类的名称、字段、方法、常量池、父类、接口、访问修饰符等。这个过程是由类加载器ClassLoader来执行，ClassLoader通过双亲委派机制来逐级负责类的加载。

2、链接：（验证 -> 准备 -> 解析）

​		2.1、验证：它的目的在于确保读取到的Class文件的字节流中包含的信息是否符合虚拟机的要求，保证被加载的类的正确性，不会危害虚拟机自身安全，包含四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。

​		2.2、准备：为类变量（static变量）分配内存并设置该类变量的默认值，这里不会为实例变量分配初始化，类变量会分配在方法区中，为实例变量实会随着对象一个分配到堆中。

​		2.3、解析：将常量池内的符号引用转换为直接引用。符号引用它并不会直接指向目标的内存地址，我们需要将符号引用解析为直接地址，直接地址会指向目标再内存中的偏移地址。解析动作主要针对于了类的接口、字段、类方法、接口方法、方法类型等。

3、初始化：初始化阶段就是执行类构造器<clinit>方法的过程。

​			<clinit>它是javac编译器自动收集此类中的所有类变量的赋值动作和代码块中的语句合并而来。

整个类的加载过程结束，相当于程序运行前的准备工作完成，然后又执行引擎来负责执行程序，利用Java运行时数据区的划分，各司其职，堆、虚拟机栈、本地方法栈、程序计数器、方法区。



ClassLoader ：bootstrapClassLoader启动类加载器、ExtClassLoader扩展类加载器、AppClassLoader应用程序类加载器

### 双亲委派机制

双亲委派机制：在加载某个类的class文件时，jvm采用的式双亲委派机制，即把请求交给父类处理。

​		1、如果一个类加载器收到了类的加载请求，它并不会自己先去加载，而是把这个请求交给自己的上级类加载器去执行；

​		2、如果上级类加载器还存在上级类加载器的话，则进一步向上委托，依次递归，请求最终将到达顶层的bootstrapClassLoader；

​		3、如果父类加载器可以完成类的加载任务，就成功返回，如果父类加载器无法完成此家在任务的话，子加载器才会进行加载。

双亲委派机制的好处：

​		1、避免类的重复加载，一个类执行被加载一次

​		2、保护程序的安全，防止核心API 被随意的篡改



## 运行时数据区

**PC寄存器**：用来存储程序当前执行的指令地址。

​	使用PC寄存器来存储字节码指令地址有什么用呢？

- - 因为CPU需要不停的切换各个线程，当CPU切换回来以后，就要知道当前线程应该从哪里开始继续执行，这时候就需要PC寄存器来记录各个线程的当前字节码指令。



**本地方法栈**：用于管理本地方法的调用

**虚拟机栈**：首先栈是解决程序的运行问题，及程序如何运行，或者说是如何处理出局。堆解决的是数据存储的问题。

- 每个线程在创建时都会创建一个虚拟机栈，其内部由一个个栈帧组成，每个栈帧对应着Java的一个个方法调用，每个方法调用以后就会入栈，方法调用结束就会出栈。所以对于栈来说，也就不涉及到垃圾回收，只要进行入栈出栈操作即可。
- 每个栈帧中 存储着 局部变量表、操作数栈、动态链接、方法返回地址。
  - 局部变量表：主要用来存储方法参数和定义在方法体内的局部变量
  - 操作数栈：主要用于保存计算过程中的中间结果
  - 动态链接：在运行的过程中将符号引用转换为直接引用，与之对应的是在类加载过程中链接阶段的解析阶段，后者是静态链接。
- 如果栈的内存大小是固定的，那么有可能会出现StackOverflowError，如果栈的大小是可以动态改变的，那么如果在扩展内存的时候无法申请到足够的内存发，就会抛出OutOfMemoryError异常。

**堆**：所有的对象实例以及数组都应当在运行时分配在堆上。但并非全部，因为还有一些对象是在栈上分配的（逃逸分析，标量替换），在方法结束时，堆中的对象并不会马上被移除，仅仅在垃圾收集的时候才会被移除。

​	逃逸分析：就是分析对象的动态作用域。当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸，若被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他方法中。	

​	标量替换：在JIT阶段，如果经过逃逸分析发现一个对象不会被外界访问，那么经过JIT优化，就会把这个对象拆解成其中包含的若干个成员变量来代替。	

堆内存的划分：

- Java7及之前堆内存逻辑上分为三部分：新生代+老年代+永久代
- Java8及以后堆内存逻辑上分为三部分：新生代+老年代+元空间，新生代又被划分为伊甸园（Eden） + 幸存区（Survivor）

​	为什么要对堆内存预计这种分代思想进一步划分呢？

​			其实对堆内进行分代划分的唯一理由就是优化GC性能，如果没有分代的话，我们进行垃圾回收的时候，GC时要找哪些对象是垃圾对象时，就要对堆内存中的所有对象进行扫描，这样整堆扫描的性能是非常低的。我们将堆空间进行分代划分后，将一些 “朝生夕死” 的对象存储在新生代，将长时间存活的对象存储在老年代，进行GC的时候我们优先对新生代的对象进行垃圾回收（Minor GC），Minor GC 之后若新生代的空间依然不足的话我们再对老年代进行垃圾回收（Major GC）。

> Minor GC：新生代收集，当Eden满了以后会触发Minor GC ，Minor GC会堆Eden和from区的对象进行垃圾回收。
>
> Major GC：老年代收集。
>
> ​			目前：只有CMS 会有单独收集老年代的行为
>
> ​			注意：很多时候Major GC回合Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收
>
> Mixed GC：混合回收，收集整个新生代以及老年代的垃圾回收。目前，只有G1会有这种行为
>
> Full GC：收集整个Java堆和方法区的垃圾回收。



TLAB：对Eden进一步划分。JVM 为每个线程在Eden内分配了一个私有缓存区域，就是TLAB。

​	为什么要有TLAB呢？

​		堆是线程共享区域，任何线程都可以访问到堆中的共享数据，还有就是在并发环境下从堆区域中划分内存空间是线程不安全的，如果没有TLAB的话，为了避免多个线程操作同一地址的话，就要使用加锁等机制，会影响分配速度。有了TLAB 后不仅可以避免多线程的安全问题，多个线程可以在自己的TLAB中并行的进行内存分配，提高了内存分配的吞吐量，也就是快速分配策略。

对象的内存分配一定在堆中吗？

​		在Java虚拟机规范中，它说明了所有Java对象的内存分配理应都在堆中。但是随着逃逸分析技术提出，如果一个对象没有发生逃逸，就可以在栈上进行对象内存的分配，这样就降低了堆内存的垃圾回收频率。但逃逸分析这项技术到目前为止并不是完全成熟，任然存在不稳定性，逃逸分析的过程中也会消耗一定的时间，如果经过一轮的逃逸分析发现并没有不逃逸的对象，那么就白白的浪费了逃逸分析的这些时间，所以说逃逸分析技术任然在发展阶段，到逃逸分析技术趋于成熟时，Java获取就能灵活的使用栈空间进行对象的分配了。

**方法区：** 方法区和Java堆一样，是各个线程共享的内存区域。我们编写的类编译成字节码文件（.class）文件以后，由classLoader类加载器加载到jvm运行时数据区以后，会将字节码文件中的信息存储在方法区中，如类型信息、常量、静态变量、JIT编译器编译后的代码缓存等一些信息。

​		方法区可以理解为一个接口，不同的虚拟机有自己对虚拟机的实现。拿hotspot虚拟机来说，在jdk1.6以及之前的版本，对于方法区的实现是永久代，这个时候永久代是在虚拟机设置的内存中。在jdk1.7是，hotspot虚拟机将永久代中的静态变量和字符串常量池移到了堆空间中。直到jdk1.8，hotspot虚拟机不再使用永久代，而是用元空间代替了永久代。元空间它的内存分配不在占用虚拟机的内存，而是直接使用本地内存。

为什么要用元空间代替永久代呢？

- 首先，永久代的空间大小的设置是很难确定的。如果空间太小，在某些场景下，如果动态加载的类过多的话，就会导致永久代空间OOM，太大的话，又会导致内存的浪费。而元空间它直接使用本地内存，内存的上限取决于本地内存的大小，不再占用虚拟机内存。

- 再就是对于方法区的垃圾回收，虽然Java虚拟机规范中并没有指出一定要对方法区进行垃圾回收，但有时我们不得不堆方法区进行垃圾回收，若某些类型信息不再使用但一直存在的话就会造成内存泄漏。

  - 方法区的垃圾回收主要针对于常量池中废弃的常量和不再使用的类型信息，对于常量的回收比较容易，主要就是对类型信息的回收很难达到一个满意的结果，因为要对一个类型信息进行回收的条件非常苛刻

    - 该类的所有实例都已经被回收
    - 加载该类的类加载器都已经被回收
    - 该类的java.lang.Class对象没有在任何地方被引用，如反射调用

    这三个条件是很难同时满足的，所以我们用元空间代替永久代以后，不在占用虚拟机内存后，jvm就不用再管理元空间的垃圾回收了，直接交给本地内存你去管理。

字符串常量池和静态变量为什么要调整位置到堆中呢？

- 我们直到方法区进行垃圾回收的收益并不是很高，所以我们很少对方法区的内存进行回收，这样就导致方法区字符串常量池和静态变量中一些废弃的变量无法及时的回收，将他们迁移到堆中后，会伴随着堆空间的垃圾回收对他们进行垃圾回收。

> 注意：成员变量存储再堆中，随着对象的创建才被初始化
>
> ​			静态变量再没有迁移到堆之前是在方法区中的，迁移到堆中以后就在堆中
>
> ​			局部变量是在栈中的局部变量表中



## 对象的实例化

**创建对象的步骤：**

1. 判断对象对应的类是否被加载、链接、初始化

   ​	当虚拟机遇到一条new指令后，首先去检查这个指令的参数能否在方法区的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化 。（即判断类元信息是否存在），如没有加载，就通过双亲委派机制对这个类进行加载，生成对应的Class对象。

2. 为对象在堆中分配内存

- 如果堆内存布局规整：采用指针碰撞
- 如果堆内存不规整，会维护一个空闲内存列表，在此列表中找到一块空闲		内存分配该此对象。

​	3.并发问题处理

​			因为堆内存时共享的，在并发环境下，对象的内存分配存在线程安全问题

- CAS方式加锁
- 先为线程分配TLAB，在TLAB中分配对象

​	4.给对象的实例变量赋初值

​	5.设置对象头信息

- 对象头中包含的信息：
  - hash值
  - GC分代年龄
  - 对象锁的状态
  - 若是偏向锁的状态，会存储偏向锁线程ID
  - 若是轻量级锁状态，存储锁记录的地址
  - 若是重量级锁状态，存储Monitor对象的地址
  - 对象的类型信息指针（指向方法区）
  - 对齐填充字段

​	6.执行<init>方法对实例变量初始化

**对象的访问定位：**

两种方式：句柄访问、直接访问（hotspot采用）

> 对象的内存布局：对象头、实例数据（包括父类的实例数据）、填充字段

## StringTable

jdk6在方法区（永久代），之后的版本把StringTable迁移到了堆中

**intern()**：jdk6由于StringTable在方法区，所以调用intern()方法，若StringTable中没有当前字符串，则在StringTable中创建一个新的String对象加入StringTable中

​				jdk7及后续版本，StringTable迁移到了堆中，为了节省堆空间，调用intern()方法，若StringTable中没有当前字符串，不会在StringTable中创建新的，而是将堆中已有的String对象的地址存到StringTable中。

new String()会创建几个对象？

两个，一个在堆中，一个在StringTable中

字符串拼接，如果右边是字符串常量或者常量引用，则会将结果放到字符串常量池中，并且底层不会使用StringBuilder拼接，而是在编译期间就会拼接

# GC

**什么是垃圾？**

- ​	在程序运行中没有任何引用指向的对象

**进垃圾回收的区域**：方法区和堆

**垃圾回收的相关算法**：

- ​	标记阶段：判断对象是否为垃圾对象

  - 引用计数算法：每个对象都维护一个引用计数器，每当一个引用指向此对象时，引用计数器加一，引用断开时，计数器减一，当计数器为0时，此对象就是垃圾对象
    - 优点：回收没有延迟
    - 缺点：引用计数器占用内存，最致命的缺点是无法解决循环引用的问题，导致出现内存泄漏
  - 可达性分析算法：从根对象集合（GC Roots）为起始点进行可达性分析，直接或间接的被GC Roots对象中的引用所连接的对象则为存活对象，引用链之外的对象就是垃圾对象。
    - 优点：可以解决循环引用问题
    - 缺点：在进行GC Roots遍历是要在某一时刻的快照进行遍历，为了保证一致性，需要用户线程需要进行STW。
    - 哪些对象可以作为GC Roots?
      - 虚拟机栈中引用指向的堆中的对象
      - 本地方法栈中引用指向堆中的对象
      - 方法区中常量引用的对象：比如：StringTable中引用的对象
      - synchronized同步锁的对象
      - Class对象
      - 在进行局部垃圾回收，比如对新生代进行垃圾回收，那么老年代的对象也可以当作GC Roots

- 清除阶段：可达性分析之后，会垃圾对象进行清除

  - 标记-清除算法：进行可达性分析阶段对存活对象进行标记，之后再遍历堆中的所有对象，将没有标记的对象进行清除
    - 缺点：标记之后还要遍历整个堆中的对象，时间消耗高，并且会存在内存碎片，导致内存空间规整，需要维护空闲列表来管理
  - 复制算法：将堆空间一分为二，只用其中一块来存储对象，垃圾回收时将存活对象复制到另一块空闲的空间，再将那一半空间整体清除
    - 优点：不会有内存碎片，并且省去了标记和遍历整堆对象的过程，速度很快
    - 缺点：浪费了一般的空间，只能用一般的空间来存储对象，由于发生了对象的移动，而再虚拟机栈中的引用是直接执行堆内存地址的，并非采用句柄的的方式，所以还要维护引用地址的变化
      - 若存活的对象很多的话，复制的开销也会变得很大，所以复制算法更多的用在新生代的垃圾回收
  - 标记-整理算法：先对对象进行标记，然后将存活对象压缩到内存的一端，再对垃圾对象进行回收。
    - 优点：不会有内存碎片，相比于复制算法也不会浪费一般的空间
    - 缺点：压缩的过程涉及到对象的移动，也要维护对象地址和引用之间的关系

  > 复制算法和标记-整理算法都不会有内存碎片，内存是规整的，所以在对对象进行内存分配是可以采用指针碰撞来分配。

- 

finalization机制：

- finalize()方法：在对象进行垃圾回收之前执行，通常在此方法中做一些资源释放和清理的工作，比如关闭文件、套接字、数据库链接等。finalize()只会被调用一次
  - 当一个对象发现再回收之前发现重写了finalize()，会将此对象放入F-queue中，由专门的finalize线程（优先级很低）来处理
  - 由于finalize()的存在，一个对象的状态被分为三种：
    - 可触及状态：即在GC Roots的引用链中，不可被回收
    - 可复活状态：对象重写了finalize()方法，在此方法中对象可能被复活
    - 不可触及状态：对象执行了finalize()方法但没有复活，或者对象没有重写finalize()，这个状态的对象才可以被回收

# 引用

强引用：我们平时用的引用就是强引用，如：Object obj = new Object()，如果对象还存在强引用关系，那么在垃圾回收的时候就一定不能对该对象进行垃圾回收。

软引用：内存不够时回收。软引用在第一次进行垃圾回收时不会进行回收，经过可达性分析以后，将不可触及的对象回收以后内存依然不够的话，就会对软引用引用的对象进行垃圾回收。

弱引用：发现即回收。它的引用强度比比软引用还弱，不管内存够不够，在gc时只要发现弱引用就会对其进行回收，软引用和若引用通常在实现缓存的时候会用得到。

虚引用：引用关系最弱的一种引用，它不会对象的生命周期产生任何影响，它的作用就是被关联的对象在被回收之后提供一个系统通知。虚引用在使用时必须配合引用队列一起使用，在虚引用关联的对象被回收之后，会将虚引用加入到引用队列中，通过处理引用队列来判断对象是否被回收。

- 在Java中对直接内存的释放就是借助引用来实现的，我们在new DirectByteBuffer()来获取直接内存后，在DirectByteBuffer对象被回收后也会将对应的直接内存释放。构造器内部会将当前对象关联到Cleaner对象中，Cleaner它继承了虚引用。Cleaner对象创建时要传入一个Deallocator线程，这个线程的任务就是调用Unsafe.freeMemory()来释放直接内存，Deallocator线程是如何被执行的呢？由于Cleaner是一个虚引用，在Reference这个抽象类中的静态代码块中会启动一个ReferenceHandler 线程，这个线程负责来处理GC过程中传递过来的Reference，当发现Reference时Cleaner时会执行clear方法，clear方法中就会执行Deallocator现车给来释放直接内存。

# 垃圾收集器

![image-20231105184722772](C:\Users\李凯\AppData\Roaming\Typora\typora-user-images\image-20231105184722772.png)

Serial：用于新生代的垃圾收集器，顾名思义，它是一种串行垃圾收集器，在进行垃圾收集时只有一个垃圾收集线程工作，在早期的单核CPU中效率很好。采用复制算法。

Serial Old：用于老年代的垃圾收集器，也是串行的，采用的时标记-整理算法。

ParNew：用于新生代的垃圾收集器，是一款并行的垃圾收集器，垃圾收集阶段有多条垃圾收集线程并行工作，采用的复制算法。ParNew虽然是并行的，但不见得一定比Serial收集器效率好，在单核CPU中，由于线程上下文切换的开销，ParNew效率不如Serial。

Parallel Scavenge：用于新生代，也是一款并行的垃圾收集器，采用复制算法。它区别于ParNew的是Parallel的设计初衷是为了实现一个可控的最大吞吐量，并且它会根据当前系统的运行情况自适应的进行调节，来达到一个最优的吞吐量。

Parallel Old：用于老年代的并行的垃圾收集器，采用标记-整理算法。在Parallel Old未发布之前，Parallel Scavenge 只能和Serial Old配合使用，直到Parallel Old出现以后，才真正的体现出Parallel的优势。

**CMS**：第一款并发的进行垃圾回收的垃圾收集器，注重响应时间，用于老年代，采用标记-清除算法。整体的执行流程分为四个阶段：

- 初始标记：这个阶段主要是对GC Roots能直接关联到的对象进行标记。会进行短暂的STW。
- 并发标记：并发标记阶段用户线程和垃圾收集线程并发的进行工作，此阶段过程长一点，但并不会进行STW。
- 重新标记：由于并发标记阶段是用户线程和垃圾收集线程并发工作，所以对象的引用关系会发生变化，出现多标漏标的情况，多标还好说，顶多产生一些浮动垃圾，漏标的话就会造成程序的运行错误，CMS采用增量更新的方式将在并发标记阶段产生新引用关系黑色对象标记为灰色，在重新标记阶段对这些对象重新进行扫描，来解决漏标的情况。
- 并发清除：垃圾收集线程和用户线程并发工作

CMS的问题：

- 无法解决浮动垃圾：并发标记阶段发生的多标的情况并不能在重新标记阶段解决，还有在并发清除阶段产生的浮动垃圾，这些垃圾只能在下一次垃圾收集时重新标记清除
- 由于用户线程和垃圾收集线程变并发执行，所以CMS不能等到内存快满的时候才进行垃圾收集，当内存占用达到一个阈值时就要进行垃圾收集，给用户线程留下执行的内存空间
- 由于采用的时标记-清除算法，所以会存在内存碎片的问题，这一点可能导致大对象没有足够的内存空间而提前触发Full GC
- 如果垃圾收集速度小于用户线程产生新的内存消耗的话，会导致并发失败，这是CMS将不得不采用后备方案，使用Serial Old船形的进行垃圾收集。
- 垃圾收集线程会占用CPU资源，导致系统的吞吐量下降

**G1**：与其他垃圾收集器相比，G1它使用了全新的分区算法，实现了可预测的时间停顿模型，在保证期望停顿时间的基础上，来实现最大的吞吐量。从分代上来看的话，他依然有新生代老年代的划分，但是它不像其他收集器对于新生代和老年代的内存还分必须是连续的，而是通过对堆空间进行分区，新生代的老年代不要求连续，用一些离散的Region来表示。每个Region之间采用的是复制算法，从整体上来看，会将非空的Region整理到一起，属于标记-整理算法。

G1垃圾收集的过程大体上可以分为三个阶段：

- 新生代收集
- 当堆内存使用达到一定阈值（默认是45%），会触发新生代的收集+对老年代进行并发标记，在并发标记过程中如果发现某个
- Region中全是垃圾，就会立刻收集，不会等到混合收集时才进行回收，并且会根据Region的垃圾收集的价值对Region进行排序
- 并发标记完成进行混合收集。混合收集是针对新生代和部分老年代进行垃圾收集，会优先收集价值大的Region，这也是G1低延迟的一方面。

在新生代收集时存在一个问题，就是跨Region引用。其他收集器也存在这种问题，解决方案都是通过记忆集 的方式来解决，只不过记忆集的实现方式不一样，G1通过记忆集来记录每个Region中存在跨Region引用的区域，在新生代收集进行标记时就不用对整个老年代进行扫描，只需要扫描记忆集中的脏卡区域就行。

在并发标记阶段也存在和CMS一样的问题，像用户线程运行过程中内存占用过快，导致并发失败，触发STW进行fullgc；漏标的情况，G1解决漏标采用的时原始快照这种算法，区别于MCS