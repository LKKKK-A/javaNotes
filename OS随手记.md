## 进程和线程的理解

​		程序的运行它是一个动态的过程，比如有时因为程序访问共享资源，会进行阻塞，使程序的执行是间断性的，而程序本身就是一些指令集，无法对程序运行过程中的而一些状态进行记录，所以就引入了进程。

​		进程它不仅包含了程序代码本身，在程序执行的过程中，进程会把能够识别程序运行状态的一些变量存放在PCB中，通过PCB中的这些变量系统就能够更好的了解程序运行的状况。进程它是OS进行资源分配的基本单位，所以导致了进程的创建和销毁代价是比较大的，因为涉及到资源的分配，比如IO设备，内存空间的分配等。进行进程切换时，要保存进行运行时的上下文环境，开销也是很大的。

​		为了提高系统的并发能力，就又引入了线程，来降低进程带来系统开销，所以说线程也有”轻量级进程“的说法。引入线程后，线程就成为了操作系统调度的基本单位，因为它更轻，不涉及到资源分配，只涉及到很小一部分必要的资源，所以线程的创建和销毁相比于进程带来的系统开销来说很小，而且进程内的线程可以并发的执行，进一步提高了系统的并发能力，甚至对于一些用户级线程，线程之间的切换都不需要操作系统的干预。

## 进程间通信方式

1. **管道通信**：管道其实就是一种特殊的文件，只不过考虑到读取的效率，将它存放在内存中。利用它进行通信时，写进程在管道一端写数据，读进程在另一端读数据，并且进程之间是利用通过字节流进行数据传输的
   1. 匿名管道：只能在具有亲缘关系的两个进程之间通信
   2. 命名管道：可以用于多个进程进行通信
2. **消息传递**：通过一些send,receive原语来实现通信
   1. 基于消息队列机制的直接通信：通过send原语指名道姓，将消息发送到目的进程对应的消息队列，读进程读取数据时在对应的消息队列中进行读取即可，相比于管道来说，消息队列的灵活性更强，因为它的数据传输是基于消息的，读写双方可以传输或读取不同类型的消息
   2. 基于信箱机制的间接通信
3. **共享内存**：共享内存的通信方式比管道和消息传递来说，它的通信效率要高很多，它不会在内核态和用户态之间来回的进行频繁切换，直接通过操作各进程共享的内存区域来实现通信，只不过这种方式要保证各进程对共享资源的互斥访问，通常回合**信号量机制**配合使用来实现进程之间的同通信
4. **Socket通信**：它可以实现跨网络的不同主机上的进程直接的通信，通过socket套接字来绑定主机ip和端口号，使用tcp或udp协议来实现进程之间的通信，只不过socket通信只能进行两个进程之间的通信。

## 调度算法

1. 先来先服务调度算法（FCFS）：它主要从进程在就绪队列中的等待时间的角度来考虑调度，对于一些长作业来说比较有利，适用于CPU密集型的进程。
2. 短作业优先调度算法（SJF）：短作业优先嘛，从执行时间的角度来进行调度，适用于IO密集型的进程。分为抢占式和非抢占式。但若是有源源不断的短作业的话，会导致长作业饥饿。
3. 高响应比优先调度算法：它结合了先来先服务和短作业优先的特点，用进程的等待时间与执行时间之和比上执行时间作为进程的响应比，根据响应比来调度。
4. 时间片轮转调度算法：它主要适用于分时操作系统中，各进程按照FCFS放入就绪队列中，将CPU的执行时间划分为一个个时间片，各进程轮流的执行一个时间片。使用时间片轮转算法的话，就需要对时间片合理的划分，若划分太大话，就退化为了FCFS算法，太小的话，就会进行频繁的进程调度，频繁的进程上下文切换，消耗系统性能。
5. 优先级调度算法：为进程设置优先级，根据优先级进行调度
6. 多级反馈队列调度算法：它设置了多级就绪队列，各就绪队列的优先级从高到低，时间片的划分从低到高的划分，并且队列内部使用FCFS算法，这种算法它结合了多种调度算法的优点，整体上来说考虑很全面的调度算法。

## 进程地址空间的划分

地址空间划分他主要就是为了解决多进程并发执行过程中的数据安全问题。通过进程地址空间划分，使得每个进程在自己独立的内存区域内活动，各进程之间互不干扰。

像在32为Linux系统中，操作系统为每个进程分配了4GB的虚拟内存空间，这4GB的虚拟内存空间由地址自下而上又被划分为了

**代码区 -> 已初始化数据区 -> 未初始化数据区 -> 堆区 -> 共享区 -> 栈区 -> 内核区**

堆区：用来给对象、数组来分配空间

栈区：用来存放方法参数和局部变量

![image](https://developer.qcloudimg.com/http-save/yehe-10455384/731417c123d18d6e1958c9f6f08510a4.png)

正是通过用虚拟内存来分配进程地址空间的这种方式，就算多个进程使用同一块虚拟地址空间，也不会冲突，因为虽然它们的虚拟地址空间相同，但操作系统会为每个虚拟内存映射到不同的空的物理内存上，并用页表来记录这种映射关系，所以说虽然虚拟地址相同，但是实际的物理内存是不一样的，这样也就实现了进程地址空间的隔离。通过虚拟地址这种方式也实现了对物理内存的扩展，当物理内存不足时，通过页面置换算法将暂时用不到的页面置换到磁盘空间，来实现对内存逻辑上的扩展。

## 死锁

死锁就是在并发环境下，各个进程或线程之间持有某些资源的同时又想获取其他的资源是进入阻塞，同时又不会释放自己的资源，导致个进程之间出现了一种僵局。

死锁发生的四个必要条件：

1. 互斥条件
2. 不剥夺条件：进程持有的资源只能有自己释放，外界不能强行剥夺
3. 请求并保持条件：当进程因请求的资源被其他进程占有而陷入阻塞时，并不会释放自己是有的资源，而是死等
4. 产生循环等待：阻塞的各个进程都在等待对方释放资源，从而产生了一个循环等待链

如何解决死锁？

- 从产生死锁的四个必要条件进行预防：
  - 破坏互斥条件：将临界资源改造成共享资源，如共享打印机就是采用SPOOLing技术将打印机改装成共享资源
  - 破坏不剥夺条件：当进程进入阻塞后，我们可以让进程主动释放自己所持有的资源，或者让OS强行剥夺
  - 破坏请求并保持：可以让进程获取到自己所需的所有资源在进入运行
  - 破坏循环等待：我们可以对资源进行编号，每个进程获取资源时只能申请编号大于自己已拥有资源的编号。这样就能保证总有一个进程它的下一个申请资源的编号是空闲的，就能保证它的顺利推进。
- 在进程进行动态分配资源的过程中避免系统进入不安全状态：
  - 通常时采用银行家算法和安全避免算法来处理
    - 银行家算法进行资源的预分配：维护了max矩阵（各进程最大资源需求数），Allocation矩阵（各进程已分配资源数），Need矩阵（各进程还需资源数）
      - 当进程请求资源时，判断此次请求是否合法，就是是否小于Need中的数据，若合法，进一步判断系统中资源剩余数是否够分配，若够的话，则进行预分配，修改各矩阵的数值，不够则阻塞
    - 安全性算法在资源与分配之后进行安全性检测：其实就是看在资源进行预分配之后能否找到一个安全序列（各进程进行资源分配的顺序），若能找到一个安全序列，则表示按照此安全序列进行资源分配的话，系统处于安全状态，进行真正的资源分配
- 万一发生了死锁我们要对其进行检测和处理
  - 使用资源分配图来保存资源的请求和分配信息，利用死锁检测算法来检测死锁
  - 检测到死锁后，我们可以根据进程优先级来进行资源剥夺，进程终止，进程回退到死锁之前的状态等一系列的方法来解除死锁









## 信号量和互斥量

信号量：它其实就是一个计数器，用来记录共享资源的存取情况，主要用于实现进程或线程之间的同步。信号量是一个非负整数，各个线程都可以对信号量进行PV操作，只有当信号量小于等于0之后，获取信号量的进程才会进入阻塞。比如说生产者消费者模式中，阻塞队列的容量可以理解为信号量，用来实现生产者和消费者直接的同步。

互斥量：它主要用来实现进程或线程之间的互斥，只有0和1两个状态。当互斥锁被某个线程获取后，其他线程只能阻塞，等待获取锁的线程释放锁，互斥量可以理解为特殊的“二值信号量”。



## 同步、异步、阻塞、非阻塞

同步和异步它是针对客户端和请求之间的关系。

同步是当客户端像服务端发出一个请求后，必须要等到获取到此请求的结果后才能继续执行，而异步指的是客户端发出请求后，不需要等待服务端响应的结果，客户端可以继续执行，当服务端处理完请求后，通过回调，给客户端一个通知即可。

阻塞和非阻塞指的是服务端的请求线程和服务线程之间的关系。

阻塞是服务端收到请求后，请求线程等待服务线程的执行结果，并在服务线程返回结果之前，请求线程会进入阻塞。

非阻塞是指在服务线程处理请求的过程中，请求线程不用阻塞，可以在此期间接受客户端的其他请求，只不过请求线程会轮询的查看每个请求的处理结果。

## 阻塞、非阻塞、同步和异步IO的区别是什么？

**IO读取数据分为两个阶段**，第一个阶段是内核准备好数据，第二个阶段是内核把数据从内核态拷贝到用户态。

第二个阶段一定会阻塞的，所以阻塞和非阻塞IO正对的都是第一个阶段，在内核准备数据的过程中，用户线程是否阻塞。

阻塞IO，当用户调用 read 后，若没有数据，用户线程会被阻塞（此时用户线程不能接受其他的客户端连接，accept()会阻塞），等内核数据准备好并且数据从内核缓冲区拷贝到用户态缓存区后， read 才会返回。

非阻塞IO是调用read后，如果没有数据就立马返回，通过不断轮询的方式去调用read，直到数据被拷贝到用户态的应用程序缓冲区，read请求才获取到结果。

同步 IO是应用程序发起一个 IO 操作后，必须等待内核把 IO 操作处理完成后才返回。无论 read 是阻塞 I/O，还是非阻塞 I/O， 都是同步调用，因为在 read 调用时，第二阶段内核将数据从内核空间拷贝到用户空间的过程都是需要等待的。

异步 IO应用程序发起一个 IO 操作后，调用者不能立刻得到结果，而是在内核完成 IO 操作后，通过信号或回调来通知调用者。异步 I/O 是内核数据准备好和数据从内核态拷贝到用户态这两个过程都不用等待。

总结一下，只有同步才有阻塞和非阻塞之分，异步阻塞没有意义。

只有用户线程在操作IO的时候根本不去考虑IO的执行，全部都交给内核去完成，
而自己只等待一个完成信号的时候，才是真正的异步IO。select、poll、epool等IO多路复用方式都是同步的。

## 



























