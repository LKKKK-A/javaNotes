LinkedBlockingQueue:
	- 设计巧妙之处：
		- 使用了两把锁(putLock和takeLock)+Dummy节点（也就是head节点）
		- 两把锁使生产者和消费和不会相互阻塞，两者可以并发的执行
		- 两把锁意味着同时可以有两个线程同时访问队列，LinkedBlockingQueue是如何保证队列的线程安全问题的呢？
		- 其实在LinkedBlockingQueue初始化的时候，会创建一个head节点，他其实就是一个哨兵节点，LinkedBlockingQueue
			- 的线程安全就是由他来保证的
			- 当队列中的元素大于1时，其实是不存在现车给安全的，因为出队时从头结点开始，入队时从尾部入队，大于1时
				- 是不会锁定同一个节点的，但当队列中只有一个节点时，生产者线程和消费者线程会访问同一个节点，
				- 倘若消费者现车提前消费，将节点删除会导致生产者空指针，有了哨兵节点，即使只有一个节点，
				- 消费者将最后1个节点消费后，并会将其删除，而是将head（哨兵）节点删除，将最后一个节点设为
				- 新哨兵节点，这样就保证了生产者不会空指针，进而保证了队列的线程安全
		- 全局使用signal，而不是signaAll，减少线程之间的竞争
		- 生产者等待队列中的线程可以由生产者自己唤醒，只有消费者线程发现capacity只差一个就满时才会唤醒一个生产者；
		消费者线程也一样
ArrayBlockingQueue:使用了一把锁，底层使用的时Node数组。性能不如LinkedBlockingQueue


		